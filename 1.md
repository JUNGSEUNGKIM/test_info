## ✅ 정보처리기사 1과목: 소프트웨어 설계 완전 정리

### ✅ 주요 구성표

| 대주제                     | 세부 내용                                      |
|-------------------------| ------------------------------------------ |
| 1. 소프트웨어 아키텍처           | 아키텍처 패턴 (파이프-필터, 데이터 중심), MVC 구조 등         |
| 2. 설계 원칙 및 기법           | 하향식/상향식 설계, 모듈화, 응집도·결합도                   |
| 3. UML 및 모델링            | Use Case, Class, Sequence, State Diagram 등 |
| 4. 요구사항 분석              | 기능/비기능 요구사항, 정형/비정형 명세, 요구사항 검증            |
| 5. 객체지향 설계              | 캡슐화, 상속, 다형성, 정보은닉                         |
| 6. 디자인 패턴               | GoF 패턴, 전략/싱글톤/프로토타입 등                     |
| 7. UI 설계                | 사용자 중심, 사용성/가독성 강조                         |
| 8. CASE 도구              | 개발 자동화, 문서 표준화 도구                          |
| 9. 품질 평가 및 표준           | ISO/IEC 25000(SQuaRE), 소프트웨어 품질 속성         |
| 10. 검토 기법               | 워크스루, 인스펙션, 기술검토                           |
| ----------------------- |2과목
| 1. 애자일 방법론              | 실행 소프트웨어, 상호작용, 피드백, 변화 수용 강조 |
| 2. 디자인 패턴               | GoF 패턴, 재사용성과 품질 향상           |
| 3. 객체지향 분석 기법           | 동적 모델링, 상향식/하향식 혼합 분석         |
| 4. 소프트웨어 검토 기법          | 워크스루, 인스펙션, 기술검토 등 리뷰 방식      |
| 5. CASE 도구              | 개발 자동화 및 문서화 도구               |
| 6. 품질 표준 및 ISO/IEC 25000 | 품질 모델 정의 및 품질 측정 기준           |

---

### 🔷 1. 소프트웨어 아키텍처

* **파이프-필터 패턴**: 데이터 흐름 중심, 오버헤드 발생 가능
* **데이터 중심 아키텍처**: 공유 저장소 기반 통신
* **MVC**: 모델-뷰-컨트롤러 구조로 결합도 낮추고 응집도 높임
  1. 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고 여러개의 다른 ui를 만들어서 그 사이에 결합도를 낮출 수 있다
  2. 뷰는 모델에 있는 데이터를 사용자 인터페이스에 보이는 역할을 한다
  3. 제어는 모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있다
  4. 모델링
     1. 구조적 방법론에서는 DFD DD 등을 사용하여 요구사항의 결과를 표현한다
     2. 객체지향 방법론에는 UML표기법을 사용한다
     3. 소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다
     4. 모델링 작업의 결과물은 다른 모델링 작업에도 영향을 준다
* **전략 패턴**: 알고리즘 캡슐화 및 교체 가능
* **싱글톤 패턴**: 인스턴스 하나만 유지
* **미들웨어**: 
  1. 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기위한 역할을 한다
  2. 송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다
  3. 상이한 애플리케이션 간 통신을 비동기 방식으로 지원한다
  4. 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다
  5. 소프트웨어 컴포넌트를 연결하기 위해 준비된 인프라 구조를 제공한다
  6. 여러 컴포넌트를 1때 1 1대 다 다대 다 등 여러가지 형태로 연결이 가능하다
  
> 📌 **추가**: 확장성, 유지보수성, 이식성 등 품질 속성 반영 필요

---

### 🔷 2. 요구사항 분석

* **기능적 요구사항**: 시스템이 수행해야 할 동작
* **비기능적 요구사항**: 성능, 보안, 품질 등
  1. 시스템의 처리랑 반응 시간등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다
  2. 시스템 구축과 관련된 안전 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다
  3. 금융 시스템은 조회 인출 입금 송금의 기능이 있어야 한다는 비 기능적 요구이다
* **정형 vs 비정형 명세**: 수학적 기호(Z명세) vs 자연어
* **요구사항 추적성(traceability)**: 변경사항 영향 추적 가능

---

### 🔷 3. 설계 기법

* **하향식 설계**: 상위에서 하위로 세부화
* **상향식 설계**: 하위 모듈 조합 후 상위 설계
* **결합도 종류**: 내용 > 공통 > 외부 > 제어 > 스탬프 > 자료
* **응집도 종류**: 우연 < 논리 < 시간 < 절차 < 통신 < 순차 < 기능
* **모듈화**:  
  1. 인터페이스
     2. 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
     3. 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어
     4. 순서적 연산에 의해 소프트웨어를 실행하는 절차
     5. **컴포넌트**: 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는재사용되는 모든 단위라고 볼 수 있으며 인터페이스를 통해서만 접근할 수 있다

---

### 🔷 4. UML 및 모델링

* **Use Case Diagram**: 사용자 요구 표현
  1. 연관, 확장, 일반화
  2. 유스케이스는 사용자 측면에서의 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다
  3. 시스템 엑터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다
  4. 엑터가 인식할 수 없느 ㄴ시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다
  5. 시스템과 상호작용하는 외부시스템은 모두 엑터다
* **Class Diagram**: 구조 표현
* **Sequence Diagram**: 시간 흐름 표현
  1. 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다
  2. 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다
  3. 회귀 메시지, 제어블록 등오로 구성된다
* **State Diagram**: 상태 변화 표현
* **DFD**: 구조적 방법론 표현 도구

---

### 🔷 5. 객체지향 설계
* **정의**:
  1. 객체는 상태 동작 고유 식별자를 가진 모든 것이라 할 수 있다
  2. 객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재이다
  3. 객체의 상태는 속성값에 의해 정의된다  
     ① Inheritance	상속: 부모 클래스로부터 속성과 메서드를 물려받는 것	 
     ② Class	객체의 설계도. 속성과 연산을 담을 수 있음       
     ④ Association	연관관계: 객체 간 연결 (예: 학생 - 강의 수강)	클래스 내부 구성과는 무관   
       Encapsulation) 캡슐화
  4. 객체란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다
  5. 상속은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다
  6. 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스라고 한다
* **캡슐화**: 정보은닉으로 모듈 간 영향 최소화
* **상속**: 상위 클래스 속성 재사용
* **다형성**:
  * 오버라이딩: 메소드 재정의
  * 오버로딩: 시그니처 다르게 중복
  1. 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게한다
  2. 다형성이란 여러가지 형태를 가지고 있다는 의미로 여러 형태를 받아들일 수 있는 특징을 말한다
  3. 메소드 오버라이딩은 상위 클래스에서 정의한 메소드의 구현을 하위 클래스에서 무시하고 재정의 할 수 있다
  4. 메소드 오버로딩의 경우 매개 변수 타입이 다르고 메소드 ㅁ여은 같게 함으로 구현 구분할 수 있다
---

### 🔷 6. 디자인 패턴

* **GoF 분류**: 생성 / 구조 / 행위 패턴
  1. 구조 패턴 : Adapter Bridge Proxy 
* **전략, 프로토타입, 싱글톤** 등 시험 단골 패턴
* **장점**: 재사용, 생산성, 품질 향상

---

### 🔷 7. UI 설계

* 사용자 중심 설계 필수 (개발자 중심 ❌)
* 가독성, 오류 처리 용이성 강조
* 피드백 제공, 다양한 계층 수용
  1. 이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야한다
  2. 주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다
  3. 사용자가 직무 연령 성별 등 다양한 계층을 수용하여야 한다
  4. 치명적이 ㄴ오류나 부정적인 사항을 사용자에게 안내하도록 해야한다
* UI 종류
  1. NUI(Natural) - 멀티 터치 동작인식 등 사용자의 자연스러운 움직임을 인식하여 서로 주고받는 정보를 제공하는 사용자 인터페이스
---

### 🔷 8. CASE 도구

* **정의**: 소프트웨어 개발 자동화 도구
* **기능**: 표준화, 문서화, 형상관리 지원

---

### 🔷 9. ISO/IEC 25000 (SQuaRE)

* **2501n 시리즈**: 품질 모델 정의
* **2502n 시리즈**: 품질 측정 요소

---

### 🔷 10. 검토 기법

* **워크스루**: 비공식, 개발자 포함
* **인스펙션**: 공식, 개발자 제외, 정적 테스트
* **기술 검토**: 회의 기반 검토

---

### 🧠 암기 키포인트

* **결합도 (강→약)**: 내용 > 공통 > 외부 > 제어 > 스탬프 > 자료
* **응집도 (약→강)**: 우연 > 논리 > 시간 > 절차 > 통신 > 순차 > 기능
* **UML 다이어그램**: UseCase, Class, Sequence, State, Activity
* **정형 명세 기법**: 수학 기반(Z 명세 등)
* **MVC 구성**: Model (데이터), View (UI), Controller (제어)

---

### 📝 참고 설명 반영 요약

* 시험에는 용어 정의와 개념 비교가 선지 형태로 자주 등장
* 워크스루/인스펙션 차이, 디자인패턴 목적, 요구사항 유형 등 암기 필요
* UI 설계는 "개발자 중심이 아닌 사용자 중심"이라는 문장이 그대로 출제됨
* 객체지향 핵심 개념 3가지 (캡슐화, 상속, 다형성) 반드시 암기
* CASE 도구와 ISO/IEC 관련 표준 명칭과 역할도 자주 출제됨

---
2과목
---

### 🔷 1. 애자일 방법론

* 실행 가능한 소프트웨어를 우선함
* 고객과의 상호작용 중시 (문서보다 대화)
* 변화에 대한 빠른 대응이 핵심
* 계획을 따르기보다 변화 수용에 가치를 둠
  * **XP[익스트림 프로그래밍]**  
  1. 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다
  2. 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 클어 올리는 것이다
  3. 구체적인 실천 방법을 정의하고 있으며 개발 문서보다는 소스코드에 중점을 둔다
> 📌 주요 키워드: 피드백, 반복, 점진적 개발, 고객 중심

---

### 🔷 2. 디자인 패턴 (GoF)

* **생성 패턴**: 객체 생성 방법 추상화 (예: 싱글톤, 팩토리, 프로토타입)
* **구조 패턴**: 클래스/객체를 조합해 더 큰 구조 구성 (예: 어댑터, 프록시)
* **행위 패턴**: 객체 간 상호작용 정의 (예: 전략, 옵저버)
* **장점**: 재사용, 의사소통 개선, 품질 향상

---

### 🔷 3. 객체지향 분석 기법

* 객체 = 데이터 + 행위 + 식별자
* 동적 모델링: 객체의 상태 변화와 메시지 교환 표현
* 하향식(기능적 분석) + 상향식(클래스 기반 분석) 병행

> 📌 UML 사용: Class Diagram, Sequence Diagram, State Diagram 등

---

### 🔷 4. 소프트웨어 검토 기법

* **워크스루**: 개발자 포함, 비공식적, 단순 시나리오 활용 검토
  1. 사용사례를 확장하여 명세하거나 설계 다이어그램 원시코드 테스트 케이스 등에 적용할 수 있다
  2. 복잡한 알고리즘 또는 방복 실시간 동작 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다
  3. 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다.
* **테스트 케이스** : 테스트를 위한 시나리오 한 묶음  
  1. 프로그램에 결함이 있더라도 입력에 대해 정상적이 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다
  2. 개발된 서비스가 정의돈 요구 사항을 준수하는지 확인하기 위한 입력값과 실행 조건 예상 결과의 집합으로 볼 수 있다
  3. 테스트 케이스 실행이 통과 되었는지 실패하였는지 판단 하기 위한 기준을 테스트 오라클 이라고 한다.
  4. 테스트 케이스(Test Case)는 테스트의 목적, 방법, 기준이 정해진 후에 작성되어야 합니다  
  5. 올바른 순서:  
     ✅ 테스트 계획 수립 (목표, 범위, 전략 정의)  
     ✅ 테스트 설계 (방법, 절차, 우선순위 정의)  
     ✅ 테스트 케이스 작성  
     ✅ 테스트 수행 및 결과 기록
  6. 화이트박스 테스트는 프로그램의 **내부 구조(로직)**를 보고 테스트하는 방식이에요.
   예: 조건문, 반복문, 분기 등을 검사함
  7. 테스트 케이스는 코드 구조를 기준으로 만듭니다.
* **인스펙션**: 개발자 제외, 공식적, 코드/문서 정적 검토
  계획 → 사전 교육 → 준비 → 인스펙션 회의 → 수정 → 후속 조치
   1️⃣ 계획	대상 선정, 참여자 지정  
   2️⃣ 사전 교육	인스펙션 방법 안내 및 기준 공유  
   3️⃣ 준비	문서 사전 읽기 및 개인 리뷰  
   4️⃣ 인스펙션 회의	오류 지적 (토론 X), 공식 회의  
   5️⃣ 수정 (Rework)	작성자가 오류 수정  
   6️⃣ 후속 조치	수정된 내용 확인, 종료 여부 판단  




* **기술검토**: 전문가나 사용자 포함 회의 중심 검토
* **검색기법**: 알고리즘
  1. 선형 검색
  2. 정렬
  3. 검색
  4. 순서대로 나열한것

> 📌 시험에 자주 나오는 워크스루 vs 인스펙션 비교 문제 주의

---

### 🔷 5. CASE 도구 (Computer-Aided Software Engineering)

* 소프트웨어 개발의 자동화 도구
* **기능**: 표준화된 개발환경 제공, 문서 자동화, 형상관리
* **유형**:

  * **전(front-end)**: 요구 분석, 설계
  * **후(back-end)**: 코드 생성, 테스트, 유지보수
* 🔁 테스트 단계 흐름 (기억하면 좋아요)   
  단위 테스트 (유닛 테스트): 개별 모듈 테스트  
  1. 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트 한다
  2. 모든 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다
  3. 테스트할 모듈을 호출하는 모듈도 있고 테스트할 모듈이 호출하는 모듈도 있다
  4. 도구 모음 : JUnit – Java   NUnit – .NET   pytest – Python  Google Test – C++  PHPUnit – PHP  
  통합 테스트: 모듈 간 연동 테스트 ✅  
  시스템 테스트: 전체 시스템 요구사항 검증  

인수 테스트: 사용자 요구사항 충족 여부 확인
* **통합테스트**:  
  1. 시스템을 구성하는 모듈의 인터페이스와 결합을 테스트 하는것이다
  2. 하향식 통합 테스트의 경우 넓이 우선 방식으로 테스트할 모듈을 선택할 수 있다
  3. 모듈간의 인터페이스와 시스템의 동작이 정상적으로 잘 되고 있는지를 빨리 파악하고자 할 때 상향식 보다는 하향식 통합 테스트를 사용하는것이 좋다
  4. 하향식 통합 테스트의 경우 시스템 구조도의 최 상위에 있는 모듈을 먼저 구현하고 테스트한다

---

### 🔷 6. ISO/IEC 25000 시리즈 (SQuaRE)

* 기존 ISO/IEC 9126 + 14598 통합
* **2501n 시리즈**: 품질 모델 (기능성, 사용성, 신뢰성 등)
* **2502n 시리즈**: 품질 측정 요소와 방법 정의
* **기타 품질 속성**: 효율성, 이식성, 유지보수성, 보안성 등
* **개발 전체 프로세스**
  1. DRM - 5과목 정보보호 문제
     1. 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자 저작권자 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다
     2. 디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리 과금 유통 단계를 관리하는 기술로도 볼 수 있다
     3. 크리어링 하우스는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말한다
     4. 콘텐츠의 불법 복제, 무단 배포, 사용 제한을 방지 
     5. 암호화, 라이선스 발급, 인증, 접근제어 등의 보안 기술을 포함 
     6. 사용자가 권한 내에서만 콘텐츠를 사용할 수 있도록 관리
  2. 위험 모니터링
     1. 위험을 이해하는것 
     2. 첫번째 조치로 위험을 피할 수 있도록 하는 것
     3. 위험 발생 후 즉시 조치하는것
---
### 🔷 7. 알고리즘

* 
---
### 🧠 암기 키포인트 요약

* 애자일 핵심 가치: 작동하는 소프트웨어, 변화 대응, 개인/상호작용, 고객 협업
* 인스펙션 vs 워크스루 차이 반드시 구분
* 디자인 패턴 분류: 생성 / 구조 / 행위
* CASE 도구는 전 공정 자동화 가능 (요구사항\~유지보수)
* ISO/IEC 25000은 소프트웨어 품질 평가 모델

---

### 📝 참고 설명 반영 요약

* 워크스루는 테스트 케이스 기반 수작업 시뮬레이션이 주로 언급됨
* 인스펙션은 눈으로 읽고 공식 절차를 따름 (정적 테스트)
* GoF 패턴은 클래스/객체 간 관계를 기반으로 다양한 설계 전략을 제공
* 애자일은 스크럼, XP 등 구체적 실천 기법으로 확장 가능함
* CASE 도구는 프로젝트 규모가 커질수록 필수로 요구됨
* ISO/IEC 번호 (2501n, 2502n) 자주 보기로 암기 추천
